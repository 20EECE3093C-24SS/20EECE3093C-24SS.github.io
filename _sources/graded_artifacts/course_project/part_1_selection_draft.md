# Part 1: Task Selection

Start by researching candidate open source projects. Make an informed decision about which project you will contribute to. As examples, consider: the type of software, the project age, the number of active contributors, the amount of activity and communication among contributors, the number and types of feature requests/bug reports you might address, the tools and mechanisms the project uses to communicate and collaborate, the dominant programming language/paradigm/framework, as well as the larger context in which the software operates. Communication with the candidate open source projects is encouraged.

Your goal is to to make a principled, informed decision as to which project and task(s) you will tackle. The type of information you collect can vary depending on how you make this decision. However, you should justify that decision by grounding it in facts about the projects and tasks you consider.

In addition, you may consider whether you want to work on a project for Social Good. If that is of interest to you, additional resources are listed at the of this document. You are not required to select a project associated with Social Good, it is merely an option.

You are required to choose a project hosted on GitHub. (This artificial constraint simplifies our grading process. If a project is hosted on GitHub in any way and is also hosted elsewhere, it counts.)

Your report should include:

1. Names and email ids. You must include your name and UM email id (e.g., "weimerw"). If you have a partner, you must include the partner name and email id as well.
    * Don't forget to tag your partner on Gradescope, not just in the PDF document. We typically have multiple groups per semester where partner A forgets to tag partner B, who then receives a zero on the assignment and doesn't notice it when assignment grades are posted, ultimately getting a lower letter grade in the class until the problem is corrected. We don't recommend that situation.
2. Overview and justification. A report on the project you selected, summarizing the relevant characteristics you considered when making your selection. Beyond whatever additional information you collect in your research, include at least a name, a website link, and a brief description of the project (what it does, who uses it, etc.). Explain the criteria you used in selecting it over any others, referencing the collected information from your overview. You may contrast it to other projects you considered but rejected, if applicable. (Approximately 2 paragraphs.)
3. Successful build. Evidence that you can build and run the software (e.g., a screenshot or text output from a successful build, a screenshot of the running program). Getting an open-source project to build and run can be a huge effort, and we want to mitigate this risk. (Many students have been unpleasantly surprised in HW6b at being unable to compile and run the program they are working on.)
    * If your project has both a front-end and a back-end (or some similar modular structure), you must show evidence of building and running both.
    * If you work with a partner, show evidence that both of you can build and run the project.
4. Task(s) description. A brief textual description of your proposed task(s). In the likely event that you are proposing to tackle several tasks, list each one and give a priority order. Depending on how difficult the issues end up being, you may not necessarily have to implement all of them. In the final report submission HW6b for you will have a chance to indicate how your actual activity deviated from this prediction. (About, or up to, 2 paragraphs per task.)
    * If the official task description is terse, you may have to read up on relevant context. For example, suppose the official pull request task description is just one sentence: "Remove buffer overruns from secondary networking module." Your report might say something like: "The tasks is to remove buffer overruns from the secondary networking module. In this program, the secondary networking module does $FOO, while the primary does $BAR. The program is structured this way for reason $BAZ. Buffer overruns are relevant because of $SECURITY_EXPLANATION. Similar changes in the past to the secondary module have struggled with $ISSUE. We hypothesize that the best way to address the problem will be by adding array bounds checks or by using $OTHER_TECHNIQUE. The project maintainer has specified that any solution must meet $READABILITY_THRESHOLD. In addition, the task implicitly requires that any new code meet the project's $COVERAGE_REQUIREMENT. To obtain that, we will also create $UNIT_TESTS ..." and so on. Note that you don't need two paragraphs, the phrasing is "up to" two paragraphs. The goal is not to convince us that you read GitHub verbatim, but more to convince us that you understand all of the things that will be involved in the task, even if, in shorthand, the developers did not say all of them out loud.
5. Task link(s). Evidence that the task(s) is/are requested by the community (a screenshot or issue tracking link suffices).
6. Requirements. A description of each task's requirements, both functional and quality. Document these requirements at whatever level of detail you consider appropriate: use cases might be helpful, for example, but are not required. You might consider how your proposed task fits into the overall goals of the project. We do not want any sort of full formal software requirements specification. Instead, we want lightweight documentation of your task's requirements and evidence that you understand how they fit into the larger project. (At most half a page per task.)
7. Initial time plan. Choose any format as long as it is clear (e.g., Gantt diagram, plain text). This should include at least: individual tasks and milestones, with deliverables (e.g., to the project maintainers); estimated effort for each (sub)task; dependencies between tasks; and a best-effort assignment of (sub)tasks to team members. We encourage you to include supporting evidence for your estimates. We will grade you on the presence of your planning but not its accuracy; it is completely acceptable if plans change. Be sure schedule time for QA activities. See the final team report for more on QA.  (At most one page.)
8. Short risk assessment. Identify and briefly describe key risks in each task and discuss how you plan to mitigate those risks. (1 paragraph, or 1 paragraph per task.)
Note that risks may be both personal (e.g., you are unfamiliar with the library, you might get sick, etc.) but may also be related to the context of the project (e.g., this GUI is hard to test, this issue is hard to reproduce, etc.). We encourage you to take the broad view of "risk" covered in class (and possibly review the early lectures for some examples).
9. Initial process plan. Describe the process you plan to follow. This should mention quality assurance and how you plan to communicate and collaborate as well as divide and integrate work. (At most half a page.)
    * In this context, the difference between a time plan and a process plan is that the former is asking you for something like a schedule (a calendar, a Gantt chart, etc.) and the latter is asking you about software process. It may be worth reviewing the Lecture on "Process, Risk and Scheduling" to see some of those terms defined.
    * Very, very informally, just to highlight the difference, "We'll use Agile" is a process description but not a time description (it says how but not when). By contrast, "We'll be done with the testing by December 4th" is a time description but not a process description (it says when but not how).
10. Task scope justification. Evidence that the tasks are of a sufficient and reasonable size and complexity (for you or your team) for this assignment. You may want to review the task scope bullet point under Task Selection and the Plan Updates bullet point under Project Report for ideas about what to include here. (1 paragraph per task)