# Grading Rubric

The following rubric will be used to evaluate your project. Each criterion will be graded on a scale of 1 to 5, with 5 being the highest score and 1 being the lowest. The total score will be calculated as the sum of the points for each criterion.

```{admonition} Course Impact
:class: warning
The course project accounts for 35% of your course grade. 
```


| Criteria               | Points | 5 - Excellent (100%)                                                                                   | 4 - Very Good (90%)                                                                         | 3 - Good (80%)                                                                       | 2 - Fair (70%)                                                                     | 1 - Poor (60%)                                                               |
|------------------------|--------|-------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| **Effort**             | 50     | Always goes beyond what is required, actively solving problems and fully engaged.                      | Often does more than required, effectively addresses challenges.                           | Meets requirements, solves problems as needed.                                      | Does just enough to meet some requirements, struggles with some challenges.    | Fails to meet basic requirements or solve problems.                        |
| **Quality**            | 10     | Work is outstanding, meeting all goals with excellent detail and functionality.                       | High-quality work, with minor areas for improvement.                                        | Good overall quality, meets the main goals with some minor issues.                    | Adequate quality, but with noticeable problems needing attention.              | Work is below expected quality, with significant issues.                   |
| **Process**            | 10     | Fully understands and applies the development process, using best practices throughout.               | Strong grasp and application of the process, with slight room for improvement.              | Understands and applies the process correctly, though some aspects could improve.     | Basic understanding and application of the process, with clear gaps.          | Lacks understanding of the process, leading to poor application.            |
| **Methods**            | 15     | Demonstrates expert knowledge and application of methods, significantly enhancing project effectiveness. | Effectively applies methods with minor areas for improvement.                               | Correctly applies methods, aligning with project needs and contributing to success.   | Applies methods to some extent, but not optimally.                            | Poor application of methods, contributing little to project success.       |
| **Tools**              | 15     | Expertly uses a wide range of tools to significantly improve project efficiency and outcomes.          | Uses tools effectively, with room for slightly better application.                          | Adequately uses tools to support project needs, though not maximized.                  | Limited or suboptimal use of tools, providing minimal benefit.               | Ineffective use of tools, hindering project progress and quality.          |


## Layered Technology in Software Engineering

Except for **effort**, the criteria are grounded in the concept of layered technology within software engineering. This model delineates the software development process through a hierarchical series of layers, with each successive layer building upon the one before it.

Here are several practical examples that illustrate how one might demonstrate an understanding of tools, methods, processes, and quality practices within this framework.


### Quality

- **Commitment to Quality**: This principle is manifested through practices such as code reviews, refactoring, and adherence to coding standards, all aimed at preserving software quality.
- **Automated Testing**: Encompassing both unit and integration tests, automated testing verifies software compliance with its requirements and upholds quality benchmarks.
- **Continuous Integration and Continuous Deployment (CI/CD)**: These methodologies automate code integration and software deployment processes, thereby maintaining consistent quality and expediting product releases.


### Process

- **Documentation**: A cornerstone of software development and maintenance, documentation covers code, architectural decisions, and user manuals.
- **Unit Testing**: This technique verifies the functionality of individual code segments, ensuring they operate as intended.
- **Integration Testing**: This approach tests the interoperability of software modules as a collective unit, confirming their seamless integration.


### Methods

- **Design Patterns**: Recognized solutions for addressing frequent design challenges, facilitating efficient problem resolution and code reuse.
- **UML Models**: The Unified Modeling Language aids in the visual representation of system designs, supporting both the documentation and comprehension of software structures and behaviors.
- **ER Diagrams**: These diagrams are pivotal in designing and visualizing database schemas, highlighting the intricate relationships between data entities.
- **Coding Style**: Maintaining a uniform coding style ensures code is readable and maintainable.
- **Agile Methodologies**: Agile practices, such as Scrum or Kanban, emphasize iterative development, collaboration, and adaptability to change.


### Tools

- **Source Control (e.g., GitHub)**: Critical for managing versions and facilitating collaboration among developers.
- **Build Systems**: Tools such as Makefiles, Gradle, and Maven are instrumental in automating the compilation of source code into executable applications.
- **Automation (e.g., GitHub Actions)**: Streamlines CI/CD workflows by automating tasks related to integration, testing, and deployment.
- **Architecture Diagram Tools**: Applications like Lucidchart or draw.io are invaluable for creating architectural diagrams, thereby enhancing the planning and visualization of software architectures.
- **Standardized Development Environments (e.g., Dev Containers)**: Utilizing containerization technology, these environments standardize development across all lifecycle stages, reducing "it works on my machine" issues and boosting productivity.
- **Project Management (e.g., GitHub Project / Repository Issues)**: These tools facilitate the planning, tracking, and reporting of project progress, ensuring efficient and transparent project management.



